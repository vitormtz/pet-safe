<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="'Detalhes do Dispositivo ' + ${device.serialNumber} + ' - PetSafe'"></title>

    <link rel="icon" type="image/x-icon" th:href="@{/images/icone_01.ico}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <link rel="stylesheet" th:href="@{/css/style.css}">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <style>
        /* Estilo para o contêiner do mapa */
        #map {
            height: 600px;
            /* Altura fixa para o mapa */
            width: 100%;
            border-radius: 0.5rem;
            position: relative;
            /* Garante que o botão flutuante seja posicionado corretamente */
        }

        #recenterButton {
            position: absolute;
            top: 10px;
            right: 50px;
            /* Ajuste para não colidir com o controle de zoom do Leaflet */
            z-index: 1000;
            /* Garante que fique acima do mapa */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .detail-icon {
            font-size: 1.25rem;
            color: #007bff;
            /* Cor primária do Bootstrap */
            min-width: 30px;
        }
    </style>
</head>

<body>
    <div th:replace="~{fragments/header :: navbar}"></div>

    <div class="container py-5" style="margin-top: 80px;">

        <div class="row mb-4">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center">
                    <h1 class="fw-bold mb-2">
                        <a th:href="@{/devices}" class="text-decoration-none text-primary me-2"><i
                                class="bi bi-arrow-left-circle"></i></a>
                        Detalhes do Dispositivo: <span th:text="${device.serialNumber}"></span>
                    </h1>
                    <span th:classappend="${device.active ? 'badge text-bg-success' : 'badge text-bg-danger'}"
                        class="fs-6 p-2">
                        <i th:classappend="${device.active ? 'bi-check-circle-fill' : 'bi-x-circle-fill'}"
                            class="me-1"></i>
                        <span th:text="${device.active ? 'Ativo' : 'Inativo'}"></span>
                    </span>
                </div>
            </div>
        </div>

        <div th:if="${locations.isEmpty()}" class="alert alert-warning" role="alert">
            <i class="bi bi-info-circle-fill me-2"></i>
            Nenhuma localização recente encontrada para este dispositivo. O mapa será centrado em uma localização
            padrão.
        </div>

        <div class="row g-4">

            <div class="col-lg-4">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white fw-bold">
                        <i class="bi bi-info-circle me-2"></i>Informações do Dispositivo
                    </div>
                    <div class="card-body">

                        <div class="d-flex align-items-center mb-3">
                            <i class="bi bi-person-badge-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">ID Interno</small>
                                <p class="mb-0 fw-bold" th:text="${device.id}">1</p>
                            </div>
                        </div>

                        <div class="d-flex align-items-center mb-3">
                            <i class="bi bi-hdd-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">Modelo</small>
                                <p class="mb-0 fw-bold" th:text="${device.model ?: 'N/A'}">Modelo XPTO</p>
                            </div>
                        </div>

                        <div class="d-flex align-items-center mb-3"
                            th:if="${device.imei != null and !device.imei.isEmpty()}">
                            <i class="bi bi-phone-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">IMEI</small>
                                <p class="mb-0 fw-bold" th:text="${device.imei}">123456789012345</p>
                            </div>
                        </div>

                        <div class="d-flex align-items-center mb-3">
                            <i class="bi bi-gear-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">Firmware</small>
                                <p class="mb-0 fw-bold" th:text="${device.firmware ?: 'N/A'}">v1.2.0</p>
                            </div>
                        </div>

                        <hr>

                        <div class="d-flex align-items-center mb-3">
                            <i class="bi bi-clock-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">Última Comunicação</small>
                                <p class="mb-0 fw-bold"
                                    th:text="${device.lastComm != null ? #temporals.format(device.lastComm, 'dd/MM/yyyy HH:mm:ss') : 'N/A'}">
                                    01/01/2025 10:30:00
                                </p>
                            </div>
                        </div>

                        <div class="d-flex align-items-center mb-3">
                            <i class="bi bi-pin-map-fill detail-icon me-3"></i>
                            <div>
                                <small class="text-muted">Última Coordenadas</small>
                                <p class="mb-0 fw-bold"
                                    th:text="${(device.lastLatitude != null and device.lastLongitude != null) ? #numbers.formatDecimal(device.lastLatitude, 1, 4) + ', ' + #numbers.formatDecimal(device.lastLongitude, 1, 4) : 'N/A'}">
                                    -23.xxx, -46.xxx
                                </p>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <div class="col-lg-8">
                <div class="card h-100">
                    <div class="card-body p-0">
                        <button id="recenterButton" class="btn btn-sm btn-primary"
                            title="Centralizar Mapa na Última Localização">
                            <i class="bi bi-bullseye"></i> Centralizar
                        </button>
                        <div id="map"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div th:replace="~{fragments/footer :: footer}"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script th:inline="javascript">
        /*<![CDATA[*/
        // Variáveis globais para o mapa e dados
        let map;
        let polylineLayer;
        let markersLayer = L.layerGroup();
        const DEVICE_ID = [[${ device.id }]];

        const API_LIMIT = [[${ locationLimit }]];
        const DISPLAY_LIMIT = [[${ mapDisplayLimit }]];

        const REFRESH_INTERVAL_MS = 30000; // 30 segundos

        const DEFAULT_LAT = -23.5505; // Centro de São Paulo
        const DEFAULT_LNG = -46.6333;

        // Armazenar a última localização conhecida para evitar repetição
        let lastKnownPosition = null;

        // Ícones Leaflet (o CSS deve estar no <style>)
        const latestIcon = L.divIcon({
            className: 'custom-latest-marker',
            html: '<i class="bi bi-pin-map-fill text-danger" style="font-size: 24px;"></i>',
            iconSize: [24, 24],
            iconAnchor: [12, 24],
            popupAnchor: [0, -20]
        });

        const historyIcon = L.divIcon({
            className: 'custom-history-marker',
            html: '<i class="bi bi-circle-fill text-primary" style="font-size: 8px;"></i>',
            iconSize: [8, 8],
            iconAnchor: [4, 4]
        });

        // FUNÇÃO DE CENTRALIZAÇÃO MANUAL
        function recenterMap() {
            if (lastKnownPosition) {
                // Centraliza o mapa na última posição conhecida com um zoom razoável
                map.setView(lastKnownPosition, 15);
                console.log("Mapa centralizado manualmente em:", lastKnownPosition);
            } else {
                console.warn("Não há posição conhecida para centralizar.");
            }
        }

        // 1. Função principal que desenha o mapa
        function drawMap(fullLocations, isInitialLoad, shouldReCenter = false) {
            const locationsToDisplay = fullLocations.slice(0, DISPLAY_LIMIT);

            let mapCenter = [DEFAULT_LAT, DEFAULT_LNG];
            let zoomLevel = 10;
            let lastLocationMarker = null;

            // Limpa as camadas existentes
            markersLayer.clearLayers();
            if (polylineLayer) {
                map.removeLayer(polylineLayer);
            }

            if (locationsToDisplay && locationsToDisplay.length > 0) {
                const latestLocation = locationsToDisplay[0];
                mapCenter = [latestLocation.latitude, latestLocation.longitude];
                zoomLevel = 15;
                lastKnownPosition = mapCenter; // Atualiza a última posição conhecida
            } else {
                lastKnownPosition = null;
            }

            // Se for a carga inicial, inicializa o objeto mapa
            if (isInitialLoad) {
                map = L.map('map', {
                    center: mapCenter,
                    zoom: zoomLevel,
                    zoomControl: false
                });

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                L.control.zoom({ position: 'topright' }).addTo(map);
                L.control.scale({ imperial: false }).addTo(map);
                markersLayer.addTo(map);
            }

            const pathCoords = [];

            // Adiciona os marcadores e constrói o caminho
            locationsToDisplay.forEach((loc, index) => {
                const position = [loc.latitude, loc.longitude];
                pathCoords.push(position);

                let iconToUse = historyIcon;
                let markerTitle = `Ponto Histórico #${locationsToDisplay.length - index}`;

                if (index === 0) {
                    iconToUse = latestIcon;
                    markerTitle = "ÚLTIMA LOCALIZAÇÃO";
                }

                console.log(loc);
                const timestamp = loc.updated_at * 1000;
                const dateStr = new Date(timestamp).toLocaleString('pt-BR');

                const marker = L.marker(position, {
                    icon: iconToUse,
                    title: markerTitle
                });

                marker.bindPopup(`
                    <div class="text-start">
                        <p class="fw-bold mb-1">${index === 0 ? 'ÚLTIMA LOCALIZAÇÃO' : 'Ponto Histórico'}</p>
                        <p class="mb-0">Tempo: ${dateStr}</p>
                        <p class="mb-0">Lat/Lng: ${loc.latitude.toFixed(4)}, ${loc.longitude.toFixed(4)}</p>
                        <p class="mb-0 text-muted">Acurácia: ${loc.accuracy ? loc.accuracy + 'm' : 'N/A'}</p>
                    </div>
                `);

                markersLayer.addLayer(marker);

                if (index === 0) {
                    lastLocationMarker = marker;
                }
            });

            // Desenha a polilinha (caminho)
            if (pathCoords.length > 1) {
                const reversedPath = [...pathCoords].reverse();
                polylineLayer = L.polyline(reversedPath, {
                    color: '#007bff',
                    weight: 5,
                    opacity: 0.7
                }).addTo(map);
            }

            // Centraliza o mapa SOMENTE se for carga inicial OU se for solicitada centralização (após um novo ponto ou clique manual)
            if (shouldReCenter && lastLocationMarker) {
                // Centraliza o mapa na última posição conhecida, mantendo o nível de zoom
                map.setView(lastLocationMarker.getLatLng(), map.getZoom());
                lastLocationMarker.openPopup();
            } else if (isInitialLoad && pathCoords.length > 0) {
                // Ajusta o mapa para mostrar todos os pontos apenas na carga inicial
                const bounds = L.latLngBounds(pathCoords);
                map.fitBounds(bounds, { padding: [20, 20] });
                lastLocationMarker.openPopup(); // Abre o popup inicial
            }

            // Abre o popup do último marcador na carga inicial se não houve ajuste de bounds
            if (isInitialLoad && lastLocationMarker && pathCoords.length <= 1) {
                lastLocationMarker.openPopup();
            }
        }

        // 2. Função que busca os novos dados
        async function fetchNewLocations() {
            try {
                const url = /*[[@{/devices/{id}/locations/json(id=${device.id}, limit=${locationLimit})}]]*/ 'default-url';

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const newLocations = await response.json();

                let shouldReCenter = false;

                // Lógica para verificar se houve atualização
                if (newLocations && newLocations.length > 0) {
                    const latestLat = newLocations[0].latitude;
                    const latestLng = newLocations[0].longitude;

                    // Compara a nova posição com a última conhecida
                    if (!lastKnownPosition ||
                        lastKnownPosition[0] !== latestLat ||
                        lastKnownPosition[1] !== latestLng) {

                        shouldReCenter = true; // Centraliza e abre o popup apenas se o ponto for novo
                        lastKnownPosition = [latestLat, latestLng]; // Atualiza a última conhecida
                        console.log("Nova localização detectada. Centralizando.");
                    } else {
                        console.log("Nenhuma nova localização detectada. Mantendo a visão atual.");
                    }
                }

                // Redesenha o mapa (passando a flag shouldReCenter)
                drawMap(newLocations, false, shouldReCenter);

            } catch (error) {
                console.error("Erro ao buscar novas localizações:", error);
            }
        }

        // 3. Inicialização
        document.addEventListener('DOMContentLoaded', function () {
            // 3.1 Desenha o mapa inicialmente
            const initialLocations = [[${ locations }]];
            drawMap(initialLocations, true, false); // Carga inicial ajusta bounds, não precisa centralizar

            // 3.2 Inicia o intervalo de atualização
            setInterval(fetchNewLocations, REFRESH_INTERVAL_MS);

            // 3.3 Adiciona listener ao botão de centralização
            const recenterBtn = document.getElementById('recenterButton');
            if (recenterBtn) {
                recenterBtn.addEventListener('click', recenterMap);
            }
        });

        /*]]>*/
    </script>
</body>

</html>